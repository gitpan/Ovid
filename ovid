#!/usr/bin/perl
use strict;
use CPAN;
use CPAN::Config;
use ExtUtils::MakeMaker;
use Getopt::Long;
use File::Spec;

use Ovid::Error;
use Ovid::Package;
use Ovid::Dependency;

our $VERSION = '0.06';

unshift @INC, File::Spec->catdir($ENV{HOME},".cpan");
eval {require CPAN::MyConfig;};

my %opts = (ignore => [], tmpdir => $ENV{TMP} || '/tmp', packager => 'unknown@localhost');

our %optionlist =
(
  'skipbuild|nobuild|n' => 'Just create the rpm spec file.',
  'ignore|i=s'  => 'Ignore specified package name. Use as frequently as necessary.',
  'forcebuild'   => 'Build the rpm even if it exists.',
  'deps|d'  => 'List dependencies.',
  'help|h'  => 'Help',
  'verbose|v+' => 'Log level',
  'tmpdir|t=s'  => 'Temporary directory',
  'packager|p'  => 'Packager',
  'version|V'     => 'Display version info',
);

exit(1) unless GetOptions(\%opts, keys %optionlist);

if ($opts{'help'}){
  my @opts;
  while (my ($k,$v) = each %optionlist){
    my ($t, undef) = split /=/, $k;
    my @t = join ' | ' , map { length($_) > 1 ? qq[--$_] : qq[-$_] } split /\|/, $t; 
    push @opts, qq[@t\t$v\n];
  }
  Usage(\@opts);
  exit 0;
}
elsif ($opts{'version'})
{
  Version();
  exit 0;
}
elsif (exists $opts{skipbuild} && exists $opts{forcebuild}) {
  warning "skipbuild and forcebuild options are mutually exclusive";
  exit 1;
}


$LOG_LEVEL = LOG_LEVEL_INFO;

if ($opts{verbose} >= 2){
  $LOG_LEVEL &= LOG_LEVEL_DEBUG | LOG_LEVEL_INFO;
}
elsif ($opts{verbose} >= 1){
  $LOG_LEVEL &= LOG_LEVEL_INFO;
}



my $src_dir = qq[$CPAN::Config->{keep_source_where}/authors/id];

my %seen;
my @queue = @ARGV;

my %packages;
my @packages;

my %ignore = map { $_, 1 } @{$opts{'ignore'}};

while (@queue)
  {
    my $item = pop @queue;

    
    if (exists $ignore{$item}){
      info "ignoring package $item";
      next;
    }
    
    my @exp = &cpan_expand($item);
    
    unless (@exp){
       warn "No match for: $item\n";
       next;
    }
    
    for my $obj (@exp){
    
      if (exists $seen{$item}){
        info "skipping previously seen package $item";
        next;
      }

      my $type = ref($obj);

      if ($type eq 'CPAN::Bundle'){
        push @queue, $obj->contains();
        next;
      }

      my %opts_args = ( basedir => $src_dir, name => $item );
      $opts_args{$_} = $opts{$_} for qw(packager tmpdir skipbuild forcebuild);

      my $package = Ovid::Package->new(%opts_args);

      
      my $archive;
      if ($type eq 'CPAN::Module'){
        
        $package->interrogate($obj);
        
        my $cpan_file = $obj->cpan_file;
        
        debug "found Module [$item]. Converting to Distribution [$cpan_file]";
        $obj = CPAN::Shell->expand("Distribution", $cpan_file);
        $type = ref($obj);
      }
      
      if ($type eq 'CPAN::Distribution')
        { 
          if ($obj->isa_perl){
            info "Skipping perl distribution for package [$item]";
            next;
          }
          
          $package->interrogate($obj);
          
          if (my @mods = $obj->containsmods)
            {
              info "distribution $item contains modules @mods";
              @seen{@mods} = (1) x scalar @mods;
            }
       
          $obj->get();

          my $dependency = Ovid::Dependency->new(dir => $obj->dir);
          
          #note: This call depends on passing dir arg to new method
          $package->builder($dependency->builder);

          $package->build_dir($obj->dir);

          unless ($package->get_description($dependency->builder)){
             $package->description($obj->as_string);
          }

          $seen{$item}++;

          if (my @dependencies = $dependency->dependencies)
            {
              for my $dep (@dependencies)
                {
                    $package->requires($dep);
                    
                    next if exists $seen{$dep->{name}};
                    
                    debug "got dependency: $dep->{name} => $dep->{version}";

                    push @queue, $dep->{name};
                }
            }
          
          push @packages, $package;
        }
    }
  }

for my $package (reverse @packages){
  if ($opts{deps}){
    print join(' ', $package->name, $package->name_string(with_version => 1, prefixed => 1)), "\n";
  }
  else {
    $package->make_rpm();
  }
}

exit 0;

#Old CPAN versions don't have expandany method. work around it.
sub cpan_expand
{
  my ($item) = @_;
  
  my $cpan = 'CPAN::Shell';
  
  if ($cpan->can('expandany')){
    return $cpan->expandany($item);
  }
  else {
      my @t;
      for my $type (qw(Author Bundle Distribution Module)){
          my @z = $cpan->expand($type, $item);
          push @t, @z if @z;
      }
      return @t;
  }
}

sub Usage
{
  my $opts = shift;
  print STDERR <<EOF;

$0: recursively builds perl CPAN modules and dependent modules as RPM files. 
usage: $0 [optons] <perl-module-name> [ <another-module> ... ]
options:
@$opts
EOF
}

sub Version
{
 print STDERR <<EOF;
$0 -- version: $VERSION
Copyright 2004 Gyepi Sam <gyepi\@praxis-sw.com>
EOF

}
exit 0;

__END__

=head1 NAME

Ovid - collection of scripts and modules for recursively converting perl CPAN modules into RPM files. 

=head1 SYNOPSIS

 perl ovid [options] <cpan::module> 

=head1 ABSTRACT

Ovid recursively downloads and builds perl CPAN modules, and most dependent modules, as RPM files.
Each RPM file lists all CPAN module dependencies so that rpm installation tools like
apt-get, urpmi, yum, and others can automatically install all dependent packages as well.

=head1 DESCRIPTION

Ovid recursively downloads and builds specified CPAN modules and all dependent modules as RPM files.
Each RPM file contains dependency information that can be used by rpm tools to automatically install
all the dependent rpm packages.

Ovid provides an automated solution to the problem of manually building dependent modules, an onerous
task at best, or giving up and using the CPAN installer.

=head1 OPTIONS

=over 4

=item  --packager | -p  "Your Name <you@example.com>"

RPM Packager. Defaults to unknown@localhost.

=item  --verbose | -v

Increase verbosity. Multiple uses has a cumulative effect.

=item  --tmpdir | -t  <tmpdir>

Temporary directory to be used for builds. Defaults to C<$ENV{TMP}> or /tmp.

=item  --help | -h

You're reading it.

=item  --skipbuild | --nobuild | -n

Just create the rpm spec file, do not build rpms.

=item --ignore | -i s

Ignore any modules named s. Can be used multiple times.

=back

=head1  BUGS

I would appreciate hearing of any problems with this program and am interested in feedback
to help improve it.


=head1 AUTHOR

Gyepi Sam, E<lt>gyepi@cpan.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2004 by Gyepi Sam

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=
